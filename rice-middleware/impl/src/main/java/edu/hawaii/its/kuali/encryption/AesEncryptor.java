package edu.hawaii.its.kuali.encryption;

import java.nio.charset.Charset;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Random;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;
import org.apache.commons.lang.ArrayUtils;

/**
 * Encrypts and decrypts Strings with AES/CBC and a random IV. Generates and
 * uses a 128 bit key, so it doesn't require modification of the Sun JDK (tested
 * in 1.6, but true I think since 1.4.2). Uses CBC to prevent repeats in the
 * plaintext from causing repeats in the ciphertext. Uses a random IV to prevent
 * the same plaintext from encrypting into the same ciphertext.
 * <p/>
 * AES with a 128-bit key is strong enough for our purposes; it was <a
 * href="http://www.cnss.gov/Assets/pdf/cnssp_15_fs.pdf">approved in 2003 by the
 * NSA</a> for US classified information up to and including SECRET.
 * 
 * @author jbeutel
 * @see <a
 *      href="http://en.wikipedia.org/wiki/Advanced_Encryption_Standard">about
 *      AES</a>
 * @see <a
 *      href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation">good
 *      overview of CBC</a>
 * @see <a
 *      href="http://java.sun.com/developer/technicalArticles/Security/AES/AES_v1.html">example
 *      AES code</a>
 * @see <a
 *      href="http://www.informit.com/articles/article.aspx?p=26343&seqNum=4">example
 *      CBC code</a>
 * @see <a href="http://www.faqs.org/rfcs/rfc3602.html">a standard use of
 *      AES/CBC</a>
 * @see <a
 *      href="http://java.sun.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html">Java
 *      Cryptography Architecture reference guide</a>
 * @see <a
 *      href="http://java.sun.com/javase/6/docs/technotes/guides/security/SunProviders.html#SunJCEProvider">Sun
 *      JCE provider</a>
 */
public class AesEncryptor
{
    // Does the JDK already have these constants somewhere?
    private static final Charset USASCII = Charset.forName("US-ASCII");
    private static final Charset UTF16 = Charset.forName("UTF-16");

    private static final Random RANDOM = new Random(); // Random enough
    private static final int IV_SIZE = 16; // AES/CBC is requiring 16 bytes
    private static final byte START_OF_PLAINTEXT_PADDING = 42; // anything but 0

    private final SecretKeySpec keySpec;
    private final Cipher cipher;

    /**
     * Constructor.
     * 
     * @param aesKeyBase64
     *            an AES secret key, base-64 encoded, e.g., generated by
     *            {@link #main}.
     */
    public AesEncryptor(String aesKeyBase64)
    {
        // AES is a block cipher, but this padding handles plaintext in lengths
        // other than multiples
        // of 16.
        this(aesKeyBase64, "PKCS5PADDING");
    }

    // package access for testing NOPADDING against RFC3602
    AesEncryptor(String aesKeyBase64, String padding)
    {
        keySpec = new SecretKeySpec(fromBase64(aesKeyBase64), "AES");
        try {
            // CBC - cipher-block chaining mode prevents repeats in the
            // plaintext from repeating
            // ciphertext
            cipher = Cipher.getInstance("AES/CBC/" + padding);
        }
        catch (NoSuchAlgorithmException e) {
            // see
            // http://java.sun.com/javase/6/docs/technotes/guides/security/SunProviders.html#SunJCEProvider
            throw new AssertionError(e); // Sun JDK 1.6 supports AES/CBC
        }
        catch (NoSuchPaddingException e) {
            throw new AssertionError(e); // Sun JDK 1.6 supports PKCS5PADDING
            // and NOPADDING
        }
    }

    // package access for testing
    synchronized byte[] doit(int mode, byte[] iv, byte[] data)
    {
        try {
            cipher.init(mode, keySpec, new IvParameterSpec(iv));
        }
        catch (InvalidKeyException e) {
            throw new IllegalArgumentException("try using a key generated by AesEncryptor.main()", e);
        }
        catch (InvalidAlgorithmParameterException e) {
            throw new AssertionError(e); // didn't happen during testing
        }

        try {
            return cipher.doFinal(data);
        }
        catch (IllegalBlockSizeException e) {
            throw new IllegalArgumentException("cannot decrypt; corrupted data?", e);
        }
        catch (BadPaddingException e) {
            throw new IllegalArgumentException("cannot decrypt; corrupted data?", e);
        }
    }

    // package access for testing
    public byte[] encrypt(byte[] plaintext)
    {
        byte[] iv = new byte[IV_SIZE];
        // using a random IV each time prevents the same plaintext from
        // generating the same
        // ciphertext
        RANDOM.nextBytes(iv);
        // the IV isn't a secret
        return ArrayUtils.addAll(iv, doit(Cipher.ENCRYPT_MODE, iv, plaintext));
    }

    // package access for testing
    public byte[] decrypt(byte[] ciphertext)
    {
        if (ciphertext.length < IV_SIZE) {
            throw new IllegalArgumentException("IV less than " + IV_SIZE + " bytes; corrupted data?");
        }
        byte[] iv = ArrayUtils.subarray(ciphertext, 0, IV_SIZE);
        byte[] encrypted = ArrayUtils.subarray(ciphertext, IV_SIZE, ciphertext.length);
        return doit(Cipher.DECRYPT_MODE, iv, encrypted);
    }

    // package access for testing
    byte[] encryptWithPadding(byte[] plaintext, int bytesIncludingPadding)
    {
        if (plaintext.length + 1 > bytesIncludingPadding) {
            throw new IllegalArgumentException("cannot pad " + plaintext.length + " bytes to " + bytesIncludingPadding);
        }
        byte[] withPadding = new byte[bytesIncludingPadding];
        assert withPadding[0] == 0 : "Java initializes arrays to all 0's";
        System.arraycopy(plaintext, 0, withPadding, 0, plaintext.length);
        withPadding[plaintext.length] = START_OF_PLAINTEXT_PADDING;
        return encrypt(withPadding);
    }

    // package access for testing
    byte[] decryptWithPadding(byte[] ciphertext)
    {
        byte[] plaintext = decrypt(ciphertext);
        if (plaintext.length < 1) {
            throw new IllegalArgumentException("empty plaintext missing padding marker; unpadded data?");
        }
        int paddingMarkerIndex = plaintext.length - 1;
        byte b = plaintext[paddingMarkerIndex];
        while (b != START_OF_PLAINTEXT_PADDING) {
            if (b != 0) {
                throw new IllegalArgumentException("invalid plaintext padding byte " + b + "; unpadded data?");
            }
            if (paddingMarkerIndex == 0) {
                throw new IllegalArgumentException("missing plaintext padding marker; unpadded data?");
            }
            b = plaintext[--paddingMarkerIndex];
        }
        return ArrayUtils.subarray(plaintext, 0, paddingMarkerIndex);
    }

    /**
     * Encrypts the given text. The plaintext is padded to a multiple of 16
     * bytes, as required by the AES block cipher, so the base-64 encoded result
     * will reveal the length of the plaintext to within 8 chars. You can hide
     * more information about the actual length by using
     * {@link #encryptWithPadding} instead.
     * <p/>
     * This method is thread-safe, because the necessary internal methods are
     * synchronized.
     * 
     * @param plaintext
     *            to encrypt
     * @return ciphertext, the base-64 encoding of a random IV and the encrypted
     *         text
     * @see #calculateEncryptedStringLength(int, boolean)
     */
    public String encrypt(String plaintext)
    {
        return toBase64(encrypt(toUtf16(plaintext)));
    }

    /**
     * Decrypts the previously encrypted text.
     * <p/>
     * This method is thread-safe, because the necessary internal methods are
     * synchronized.
     * 
     * @param ciphertext
     *            base-64 encoding of encrypted text preceded by the IV used to
     *            encrypt it
     * @return plaintext
     */
    public String decrypt(String ciphertext)
    {
        return fromUtf16(decrypt(fromBase64(ciphertext)));
    }

    /**
     * Encrypts the given text, padding it to the given number of chars. The
     * encrypted result is longer, but hides whether the plaintext is shorter.
     * Use {@link #decryptWithPadding} to decrypt this result and remove its
     * padding.
     * <p/>
     * This method is thread-safe, because the necessary internal methods are
     * synchronized.
     * 
     * @param plaintext
     *            to encrypt
     * @param charsIncludingPadding
     *            the returned ciphertext will look like the plaintext had this
     *            many chars
     * @return ciphertext, the base-64 encoding of a random IV and the
     *         encrypted, padded text
     * @see #calculateEncryptedStringLength(int, boolean)
     */
    public String encryptWithPadding(String plaintext, int charsIncludingPadding)
    {
        if (plaintext.length() > charsIncludingPadding) {
            throw new IllegalArgumentException("cannot pad " + plaintext.length() + " chars to " + charsIncludingPadding);
        }
        int plaintextBytesIncludingPadding = charsIncludingPadding * 2; // UTF-16
        // encoding
        plaintextBytesIncludingPadding += 2; // for UTF-16 byte-order mark
        plaintextBytesIncludingPadding += 1; // for plaintext padding marker
        // byte
        return toBase64(encryptWithPadding(toUtf16(plaintext), plaintextBytesIncludingPadding));
    }

    /**
     * Decrypts text that was previously encrypted and padded by
     * {@link #encryptWithPadding}.
     * <p/>
     * This method is thread-safe, because the necessary internal methods are
     * synchronized.
     * 
     * @param ciphertext
     *            base-64 encoding of encrypted, padded text preceded by the IV
     *            used to encrypt it
     * @return plaintext without padding
     * @throws IllegalArgumentException
     *             if the given ciphertext was not produced by
     *             {@link #encryptWithPadding}
     */
    public String decryptWithPadding(String ciphertext)
    {
        return fromUtf16(decryptWithPadding(fromBase64(ciphertext)));
    }

    private static String toBase64(byte[] bytes)
    {
        return new String(Base64.encodeBase64(bytes), USASCII);
    }

    private static byte[] fromBase64(String s)
    {
        return Base64.decodeBase64(s.getBytes(USASCII));
    }

    private static byte[] toUtf16(String s)
    {
        // Using UTF-16 for fixed-width results. This encoding is internal,
        // because it's inside the
        // encryption.
        byte[] bytes = s.getBytes(UTF16);
        assert bytes.length == s.length() * 2 + 2; // for encryptWithPadding(),
        // +2 is UTF-16 byte
        // order mark
        return bytes;
    }

    private static String fromUtf16(byte[] bytes)
    {
        return new String(bytes, UTF16);
    }

    /**
     * Calculates the length that an encrypted String would be. This is tested
     * documentation to help programmers plan their space requirements, e.g.,
     * for encrypted database columns.
     * 
     * @param stringLength
     *            the {@link String#length length} of the String to encrypt
     * @param withPlaintextPadding
     *            whether the String is to be padded to the given fixed length
     * @return the length that the encrypted String would be
     */
    public static int calculateEncryptedStringLength(int stringLength, boolean withPlaintextPadding)
    {
        int utf16Bytes = stringLength * 2;
        utf16Bytes += 2; // for byte-order mark
        utf16Bytes += withPlaintextPadding ? 1 : 0;
        int cipherBlocks = blocksOf(utf16Bytes + 1, 16); // +1 byte for at least
        // one 0 byte of
        // pcks5padding
        int encryptedBytes = 16 * (cipherBlocks + 1); // +1 block for
        // unencrypted IV
        int base64blocks = blocksOf(encryptedBytes, 3); // base 64 converts
        // blocks of 3 bytes...
        return base64blocks * 4; // into 4 chars; 2^6 == 64; 6 bits * 4 chars ==
        // 8 bits * 3 bytes;
        // padded with '='
    }

    private static int blocksOf(int bytes, int blockSize)
    {
        return bytes / blockSize + (bytes % blockSize == 0 ? 0 : 1); // is there
        // an
        // easier
        // expression for this?
    }
}
